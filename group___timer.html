<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.11"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>sdl++: Timer Support</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
        <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="/Users/travis/build/tcbrindle/sdlxx/doc/MathJax.js/MathJax.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link rel="stylesheet" href="bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">sdl++ </a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Timer Support</div>  </div>
</div><!--header-->
<div class="contents">

<p>This category contains functions for handling the SDL time management routines.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:structsdl_1_1clock"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___timer.html#structsdl_1_1clock">sdl::clock</a></td></tr>
<tr class="memdesc:structsdl_1_1clock"><td class="mdescLeft">&#160;</td><td class="mdescRight">An STL-compatible clock type.  <a href="group___timer.html#structsdl_1_1clock">More...</a><br /></td></tr>
<tr class="separator:structsdl_1_1clock"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga6ad92fabb9a703863b7415e09150add3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___timer.html#ga6ad92fabb9a703863b7415e09150add3">sdl::time_point</a> = clock::time_point</td></tr>
<tr class="memdesc:ga6ad92fabb9a703863b7415e09150add3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialization of <code>std::chrono::time_point</code> used to represent timestamps in sdl++.  <a href="group___timer.html#ga6ad92fabb9a703863b7415e09150add3">More...</a><br /></td></tr>
<tr class="separator:ga6ad92fabb9a703863b7415e09150add3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70acb7d91d1250ab69a4f5eb1ecc0df5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___timer.html#ga70acb7d91d1250ab69a4f5eb1ecc0df5">sdl::duration</a> = clock::duration</td></tr>
<tr class="memdesc:ga70acb7d91d1250ab69a4f5eb1ecc0df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialization of <code>std::chrono::duration</code> used to represent a time interval in sdl++.  <a href="group___timer.html#ga70acb7d91d1250ab69a4f5eb1ecc0df5">More...</a><br /></td></tr>
<tr class="separator:ga70acb7d91d1250ab69a4f5eb1ecc0df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15647df3a0acfd6fe0cb814f2ff1e3e6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___timer.html#ga15647df3a0acfd6fe0cb814f2ff1e3e6">sdl::timeout_callback_t</a> = optional&lt; duration &gt;(duration)</td></tr>
<tr class="memdesc:ga15647df3a0acfd6fe0cb814f2ff1e3e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of callable expected by <code><a class="el" href="group___timer.html#ga8e44931ac4902aa8311a59af045b1830" title="Add a new timer to the pool of timers already running. ">make_timeout()</a></code>.  <a href="group___timer.html#ga15647df3a0acfd6fe0cb814f2ff1e3e6">More...</a><br /></td></tr>
<tr class="separator:ga15647df3a0acfd6fe0cb814f2ff1e3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4b696b5ae999acce9b83d99b67c30642"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4b696b5ae999acce9b83d99b67c30642"></a>
static time_point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___timer.html#ga4b696b5ae999acce9b83d99b67c30642">sdl::clock::now</a> () noexcept</td></tr>
<tr class="memdesc:ga4b696b5ae999acce9b83d99b67c30642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code>time_point</code> representing the current value of the clock. <br /></td></tr>
<tr class="separator:ga4b696b5ae999acce9b83d99b67c30642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e660bc06e82675947382ec8aa89a805"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___timer.html#ga2e660bc06e82675947382ec8aa89a805">sdl::get_performance_counter</a> ()</td></tr>
<tr class="memdesc:ga2e660bc06e82675947382ec8aa89a805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of ticks of the high performance counter since SDL was initialized.  <a href="group___timer.html#ga2e660bc06e82675947382ec8aa89a805">More...</a><br /></td></tr>
<tr class="separator:ga2e660bc06e82675947382ec8aa89a805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6688fab2a57d4325278af88505d99a80"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___timer.html#ga6688fab2a57d4325278af88505d99a80">sdl::get_performance_frequency</a> ()</td></tr>
<tr class="memdesc:ga6688fab2a57d4325278af88505d99a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ticks per second of the high performance counter.  <a href="group___timer.html#ga6688fab2a57d4325278af88505d99a80">More...</a><br /></td></tr>
<tr class="separator:ga6688fab2a57d4325278af88505d99a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga122f832b4dd6f68da0880e52b746b838"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___timer.html#ga122f832b4dd6f68da0880e52b746b838">sdl::delay</a> (duration interval)</td></tr>
<tr class="memdesc:ga122f832b4dd6f68da0880e52b746b838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait a specfied time interval before returning.  <a href="group___timer.html#ga122f832b4dd6f68da0880e52b746b838">More...</a><br /></td></tr>
<tr class="separator:ga122f832b4dd6f68da0880e52b746b838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e44931ac4902aa8311a59af045b1830"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:ga8e44931ac4902aa8311a59af045b1830"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___timer.html#ga8e44931ac4902aa8311a59af045b1830">sdl::make_timeout</a> (duration interval, Func &amp;&amp;callback)</td></tr>
<tr class="memdesc:ga8e44931ac4902aa8311a59af045b1830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new timer to the pool of timers already running.  <a href="group___timer.html#ga8e44931ac4902aa8311a59af045b1830">More...</a><br /></td></tr>
<tr class="separator:ga8e44931ac4902aa8311a59af045b1830"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gadb06a4473403b5474f53228fd29b35f3"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___timer.html#gadb06a4473403b5474f53228fd29b35f3">sdl::clock::is_steady</a> = true</td></tr>
<tr class="memdesc:gadb06a4473403b5474f53228fd29b35f3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group___timer.html#structsdl_1_1clock" title="An STL-compatible clock type. ">sdl::clock</a> is monotonically increasing and not affected by changes to the system clock.  <a href="#gadb06a4473403b5474f53228fd29b35f3">More...</a><br /></td></tr>
<tr class="separator:gadb06a4473403b5474f53228fd29b35f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This category contains functions for handling the SDL time management routines. </p>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="structsdl_1_1clock" id="structsdl_1_1clock"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sdl::clock</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>An STL-compatible clock type. </p>
<p><code><a class="el" href="group___timer.html#structsdl_1_1clock" title="An STL-compatible clock type. ">sdl::clock</a></code> is a clock type which models the standard library concepts <a href="http://en.cppreference.com/w/cpp/concept/Clock">Clock</a> and <a href="http://en.cppreference.com/w/cpp/concept/TrivialClock">TrivialClock</a>.</p>
<p>This clock counts the number of milliseconds since the SDL library was initialized. In order to use it, you will need to create an <code><a class="el" href="group___init.html#structsdl_1_1init__guard" title="RAII initialization guard. ">sdl::init_guard</a></code> with the <code><a class="el" href="group___init.html#ggaa7d4ead440d5f89064cf1df56ae76297a2c127bf32ccb4edf2bf22fea5a00e494" title="The timer subsystem. ">sdl::init_flags::timer</a></code> flag set.</p>
<dl class="section note"><dt>Note</dt><dd>This clock has a fairly low resolution, and a short rollover period (approximately 49 days). It is mostly intended to serve as a bridge between the SDL and STL notions of time. One of the standard library-provided clocks, for example <code>std::chrono::high_resolution_clock</code>, may be better suited for general purpose use. </dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Static Public Member Functions</h3></td></tr>
<tr class="memitem:ga4b696b5ae999acce9b83d99b67c30642"><td class="memItemLeft" align="right" valign="top">
static <a class="el" href="group___timer.html#ga6ad92fabb9a703863b7415e09150add3">time_point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___timer.html#ga4b696b5ae999acce9b83d99b67c30642">now</a> () noexcept</td></tr>
<tr class="memdesc:ga4b696b5ae999acce9b83d99b67c30642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code>time_point</code> representing the current value of the clock. <br /></td></tr>
<tr class="separator:ga4b696b5ae999acce9b83d99b67c30642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Static Public Attributes</h3></td></tr>
<tr class="memitem:gadb06a4473403b5474f53228fd29b35f3"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___timer.html#gadb06a4473403b5474f53228fd29b35f3">is_steady</a> = true</td></tr>
<tr class="memdesc:gadb06a4473403b5474f53228fd29b35f3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group___timer.html#structsdl_1_1clock" title="An STL-compatible clock type. ">sdl::clock</a> is monotonically increasing and not affected by changes to the system clock.  <a href="group___timer.html#gadb06a4473403b5474f53228fd29b35f3">More...</a><br /></td></tr>
<tr class="separator:gadb06a4473403b5474f53228fd29b35f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga70acb7d91d1250ab69a4f5eb1ecc0df5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group___timer.html#ga70acb7d91d1250ab69a4f5eb1ecc0df5">sdl::duration</a> = typedef clock::duration</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A specialization of <code>std::chrono::duration</code> used to represent a time interval in sdl++. </p>
<p>Note that the standard library provides converting constructors between compatible duration types, so it's possible to (for example) pass a value of <code>std::chrono::seconds</code> to a function expecting an <code>sdl::duration</code>. </p>

</div>
</div>
<a class="anchor" id="ga6ad92fabb9a703863b7415e09150add3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group___timer.html#ga6ad92fabb9a703863b7415e09150add3">sdl::time_point</a> = typedef clock::time_point</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A specialization of <code>std::chrono::time_point</code> used to represent timestamps in sdl++. </p>
<p>The value itself is mostly meaningless. </p>

</div>
</div>
<a class="anchor" id="ga15647df3a0acfd6fe0cb814f2ff1e3e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group___timer.html#ga15647df3a0acfd6fe0cb814f2ff1e3e6">sdl::timeout_callback_t</a> = typedef optional&lt;duration&gt;(duration)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of callable expected by <code><a class="el" href="group___timer.html#ga8e44931ac4902aa8311a59af045b1830" title="Add a new timer to the pool of timers already running. ">make_timeout()</a></code>. </p>
<p>The callback is passed the current timer interval and returns the next timer interval. If the returned value is the same as the one passed in, the periodic alarm continues, otherwise a new alarm is scheduled. If the callback returns <code>nullopt</code> or a duration of zero, the callback will not be fired again. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga122f832b4dd6f68da0880e52b746b838"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sdl::delay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___timer.html#ga70acb7d91d1250ab69a4f5eb1ecc0df5">duration</a>&#160;</td>
          <td class="paramname"><em>interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait a specfied time interval before returning. </p>
<dl class="section note"><dt>Note</dt><dd>The standard library provides <code>std::this_thread::sleep_for()</code> and <code>std::this_thread::sleep_until()</code> which may be preferred to this function. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2e660bc06e82675947382ec8aa89a805"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t sdl::get_performance_counter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of ticks of the high performance counter since SDL was initialized. </p>
<p>Depending on the platform, this may or may not have a higher resolution than <code><a class="el" href="group___timer.html#ga4b696b5ae999acce9b83d99b67c30642" title="Returns a time_point representing the current value of the clock. ">sdl::clock::now()</a></code>. Note that unfortunately SDL does not expose the high- frequency tick period as a compile-time constant, so we cannot have a high-res version of <a class="el" href="group___timer.html#structsdl_1_1clock" title="An STL-compatible clock type. ">sdl::clock</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The standard library provides <code>std::chrono::high_resolution_clock</code>, which should be preferred to using this function.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___timer.html#ga6688fab2a57d4325278af88505d99a80" title="Get the ticks per second of the high performance counter. ">sdl::get_performance_frequency()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6688fab2a57d4325278af88505d99a80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t sdl::get_performance_frequency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ticks per second of the high performance counter. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___timer.html#ga2e660bc06e82675947382ec8aa89a805" title="Returns the number of ticks of the high performance counter since SDL was initialized. ">sdl::get_performance_counter()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8e44931ac4902aa8311a59af045b1830"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sdl::make_timeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___timer.html#ga70acb7d91d1250ab69a4f5eb1ecc0df5">duration</a>&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new timer to the pool of timers already running. </p>
<p>The supplied callback will be called when (or soon after) the given interval has elapsed, and will be passed the actual time interval as its argument. The callable must return the delay until the next timeout, or the special duration value zero to signify that it should not be called again.</p>
<p>This function returns a callback handle, the destructor of which takes care of removing the callback. This means that you must keep the return value of this function alive for as long as you want the callback to be called.</p>
<dl class="section note"><dt>Note</dt><dd>This means that to do anything useful you <em>must</em> capture the result of this function. Simply calling</dd></dl>
<div class="fragment"><div class="line">make_timer(1s, functor);</div></div><!-- fragment --><p>will result in the timeout being added and then immediately removed when the temporary return value of the function is destroyed. Instead you should say</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> handle = make_timer(1s, functor);</div></div><!-- fragment --><p>The callback will then be run regularly for as long as the variable <code>handle</code> is in scope.</p>
<dl class="section warning"><dt>Warning</dt><dd>The callback will be called in a different thread. Be very careful about what you do inside the callback function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interval</td><td>An <code>sdl::duration</code> after which the callback will be called </td></tr>
    <tr><td class="paramname">callback</td><td>A callable (a function, functor, lambda etc) which can be called with a single argument of type <code>sdl::duration</code> and which returns an <code>sdl::duration</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A move-only RAII handle representing the callback.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structsdl_1_1error.html" title="Exception type thrown by sdl++ functions if exceptions are enabled. Inherits from std::runtime_error...">sdl::error</a></td><td>If the callback could not be added </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="gadb06a4473403b5474f53228fd29b35f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool sdl::clock::is_steady = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="group___timer.html#structsdl_1_1clock" title="An STL-compatible clock type. ">sdl::clock</a> is monotonically increasing and not affected by changes to the system clock. </p>
<dl class="section warning"><dt>Warning</dt><dd><a class="el" href="group___timer.html#structsdl_1_1clock" title="An STL-compatible clock type. ">sdl::clock</a> will roll over if the program runs for more than ~49 days. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
